package model_4;

/**
 * @Author 远志 zhangsong@cskaoyan.onaliyun.com
 * @Date 2024-08-24 22:16
 * @Version 1.0
 * JVM内存模型
 * JVM四大模块：运行时数据区（内存模型？）、类加载器子系统、执行引擎、GC（垃圾回收器）。
 * java代码经过编译之后形成class文件，class文件被类加载器加载到内存中
 * class数据被解析成一个Klass对象和镜像对象，分别位于方法区和堆上
 * 不同版本的JVM虚拟机对于方法区的实现是不同的
 * 永久代：jdk8之前使用的形式，位于JVM的堆区
 * 元空间：jdk8之后，直接内存中，位于本地内存中
 * 为什么做这种转变？
 *      1.永久代的缺点：很难触发卸载机制、释放的内存很少
 * JVM内存模型和操作系统的内存模型
 * JVM其实本质上来说便是位于操作系统中的一个应用程序，进程
 * 操作系统：
 *      代码段
 *      数据区
 *      栈
 *      堆(JVM内存空间是基于这部分进一步扩展的)
 *          JVM内存模型
 *              虚拟机栈
 *              本地方法栈
 *              堆区
 *              程序计数器
 *          方法区(直接内存)
 *  常见问题：
 *  1.为什么java对象不在jvm的栈上进行分配呢？jvm的栈是受到操作系统自动管理的，随时可能被回收
 *  2.为什么不直接使用jvm堆(直接内存),而要重新实现JVM内存模型呢？因为C++堆内存是程序员分配和释放的，jvm需要实现自动GC功能，直接使用jvm堆无法实现
 *  虚拟机栈：和线程是1:1的关系；一个虚拟机栈中有多少栈帧？方法被调用了多少次
 *  栈帧：
 *      局部变量表：存储局部变量的；1.局部变量表有多大？编译的时候就已经确定了 2.静态和非静态方法的区别？index=0的位置是否有this指针 3.哪些数据会存储在局部变量表？参数、局部变量
 *      操作数栈
 *      动态链接:间接引用转换成直接引用 c++内存地址
 *      返回地址：保存现场
 *      轻量级锁
 *  堆区：
 *      最小是物理内存的1/64，最大是1/4
 *      老年代的容量要大于新生代 原因在于老年代要存储的对象比新生代多的多(gc>15的对象;)
 */

public class JVMModel {

    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        System.out.println("Hello World");
    }

    public static int add(int a, int b) {
        int c = 10;
        int d = 20;
        a = a + c;
        b = b + d;
        return a + b;
    }

    public int m1(int a, int b) {
        int m = 100;
        return a + b;
    }
}
