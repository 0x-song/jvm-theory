package gca_8;

/**
 * @Author 远志 zhangsong@cskaoyan.onaliyun.com
 * @Date 2024-09-03 20:42
 * @Version 1.0
 * 垃圾回收：
 *  标记 垃圾判断算法
 *          存活对象（标记）
 *          没在使用的对象（没有引用指向）
 *          引用计数算法：在对象中添加一个属性用来标记对象被引用的次数，多一个其他对象引用，计数+1，无法解决循环依赖问题
 *          可达性分析算法：从一个根开始逐个对象进行分析
 *  收集 垃圾回收算法
 *      收集
 *
 *  垃圾回收器：标记 + 收集
 *
 *
 *  内存池：可以理解为JVM内存模型的管理器。为什么要有内存池？避免频繁地去向操作系统去申请分配、释放内存
 *  内存池里面包含内存块，内存块进一步包含内存cell，一个cell占8个字节，一个对象对应于多个cell
 *  给对象分配cell这些空间，那么后续便需要回收这些空间，这便是垃圾收集器诞生的由来
 *
 *  垃圾回收算法：
 *      标记-清除算法：从根对象开始，通过引用链来追踪标记所有的活动对象；未被标记的对象被视为垃圾对象，进行内存释放
 *                   但是该算法的缺点在于存在内存碎片化问题
 *      标记-整理算法：其实就是合并内存碎片，让内存合并到连续状态，缺点是耗费CPU。内存碎片合并算法
 *      分代-复制算法：分为新生区（伊甸园区、幸存者from区、幸存者to区）和养老区两大类
 *                  每次GC之后，伊甸园区存活的对象复制到幸存者from区，所以一旦GC过后，伊甸园区是空的
 *                  每次都会将from区的对象复制到to区，然后删除from区对象；并且to区和from区互换，所以to区始终是空的
 *                  一个对象经历15次GC之后，便会进入到养老区
 *                  没有内存碎片，但是浪费内存空间
 *
 *  所有的垃圾回收算法都需要经历标记阶段。如果GC线程在标记的时候暂停所有用户线程，那么就不需要三色标记算法了，但是这就导致了一个问题
 *  用户线程必须得GC线程标记完才能运行，给人的感觉是很卡
 *  遍历对象的过程中遇到的对象，按照是否访问过这个条件进行标记：
 *  白色：尚未访问过
 *  黑色：本对象已经访问过，而且本对象引用到的其他对象也全部访问过了
 *  灰色：本对象已经访问过，但是本对象引用到的其他对象尚未全部访问完，全部访问完之后会被标记黑色
 *  标记开始的时候全部都是白色，被引用的对象标记为灰色，扫描完全部的引用对象之后标记为黑色，最终标记结束的时候还是白色的便是垃圾
 *
 *  问题：
 *  D--------> E ---------> F
 *  多标：垃圾回收线程已经扫描完D，E此时已经被标记了灰色，但是用户线程将D.E=NULL，按说应该是白色，但是已经被标记成了灰色，下次周期会将他们回收
 *  D---------E
 *
 *
 *            G
 *  漏标：E对G的引用断开，D对G的引用新增；
 *       灰色对白色的引用断开  ------原始快照解决该问题 断开之前记录
 *       黑色对白色的引用建立  -----增量更新解决该问题  更新之后记录
 *
 *  少标：并发标记开始之后的创建的对象，都视为黑色，本轮GC不清除
 *
 *
 *
 *  年轻代的对象朝生夕死，老年代的对象存活时间较久。因此JVM对于年轻代的垃圾回收频率肯定是比老年代的收集频率高得多
 *  但是在JVM中存在跨代引用的情况，也就是老年代的对象引用了年轻代的对象。JVM在进行GC时，只会对年轻代进行扫描，不会扫描老年代，如果一个年轻代
 *  对象只存在老年代的引用，GC是扫描不到它的
 *  如果此时全部扫描老年代，效率很低，JVM定义了一个记忆集，用于记录非收集区对于收集区的引用
 *  记忆集是一个抽象的概念，Hotspot的实现形式是卡表
 *  首先将内存划分为一块一块的区域，叫做卡页，定义一个字节数组，就是卡表，卡表中的每一个字节，对应内存中的一个卡页。
 *  如果一个老年代的对象引用了年轻代的对象，那么老年代对象所在的卡页在卡表对应的位置标记为1，表示该卡页脏了
 *  JVM收集年轻代时，便去扫描哪些老年代的卡页是脏页，这样便可以知道哪些老年代的对象引用该年轻代对象
 *
 *
 *
 *
 */
public class GarbageCollect {
}
